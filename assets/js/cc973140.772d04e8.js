"use strict";(self.webpackChunksuberra_docs=self.webpackChunksuberra_docs||[]).push([[869],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>f});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(n),f=o,m=u["".concat(l,".").concat(f)]||u[f]||d[f]||a;return n?r.createElement(m,i(i({ref:t},p),{},{components:n})):r.createElement(m,i({ref:t},p))}));function f(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var c=2;c<a;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2111:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var r=n(7462),o=(n(7294),n(3905));const a=n.p+"assets/images/periodic_allowance-02ed7dcc3ee66ff0df8f297e548a1da2.png",i={title:"Periodic Allowances",description:"Periodic allowances",slug:"/periodic-allowances"},s=void 0,l={unversionedId:"overview/periodic_allowance",id:"overview/periodic_allowance",title:"Periodic Allowances",description:"Periodic allowances",source:"@site/docs/0_overview/periodic_allowance.mdx",sourceDirName:"0_overview",slug:"/periodic-allowances",permalink:"/docs/periodic-allowances",draft:!1,editUrl:"https://github.com/suberra/suberra-docs/docs/0_overview/periodic_allowance.mdx",tags:[],version:"current",frontMatter:{title:"Periodic Allowances",description:"Periodic allowances",slug:"/periodic-allowances"},sidebar:"docs",previous:{title:"What is Suberra",permalink:"/docs/overview/what_is_suberra"},next:{title:"Use Cases",permalink:"/docs/overview/use_cases"}},c={},p=[{value:"Periodic allowances",id:"periodic-allowances",level:2},{value:"Technical Specifications",id:"technical-specifications",level:2},{value:"<code>approve</code>",id:"approve",level:3},{value:"<code>permit</code>",id:"permit",level:3},{value:"<code>transferFrom</code>",id:"transferfrom",level:3},{value:"<code>allowanceInfo</code>",id:"allowanceinfo",level:3}],d={toc:p};function u(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("hr",null),(0,o.kt)("p",null,"Most dApps requires users to grant an allowance to spend tokens for it to work. For example, if you are trying to trade on Uniswap, Uniswap will require you to approve Uniswap contracts to spend tokens on your behalf. This is done by calling the ",(0,o.kt)("inlineCode",{parentName:"p"},"approve")," function on the token contract. The ",(0,o.kt)("inlineCode",{parentName:"p"},"approve")," function takes two arguments, the address of the spender and the amount of tokens to be approved. The spender is the address of the contract that will be spending the tokens on your behalf. The amount is the maximum amount of tokens that can be spent by the spender. The ",(0,o.kt)("inlineCode",{parentName:"p"},"approve")," function is a one-time function, meaning that you can only call it once. If you want to change the amount of tokens that can be spent by the spender, you will have to call the ",(0,o.kt)("inlineCode",{parentName:"p"},"approve")," function again with the new amount."),(0,o.kt)("p",null,"This is a security feature to prevent dApps from stealing your tokens. However, it is a very inconvenient UX for users. Users have to approve the dApp every time they want to use it."),(0,o.kt)("p",null,"For programs that is designed to repeat the same action over time, many developers chose to request for a large (or unlimited) approval from the user. This is a bad practice because it is a security risk. If the developer is malicious or if the dApp is compromised, then the funds in the users wallets can be drained completely."),(0,o.kt)("h2",{id:"periodic-allowances"},"Periodic allowances"),(0,o.kt)("div",{style:{flexBasis:"300px",flexGrow:"1",textAlign:"center"}},(0,o.kt)("img",{src:a,style:{alignSelf:"center",maxWidth:"100%"}})),(0,o.kt)("p",null,"Suberra protects users by building another layer of stricter contraints on EIP-20 allowances. These constraints restricts the amount of tokens that can be spent by the dApp. This is done by setting a maximum allowance that can be spent in a period of time (e.g. 50 USDC per month). Once the smart contract use up the allowance for the given period of time, it can no longer spend any tokens from the user's wallet. This periodic allowance is reset the next unit interval."),(0,o.kt)("h2",{id:"technical-specifications"},"Technical Specifications"),(0,o.kt)("h3",{id:"approve"},(0,o.kt)("inlineCode",{parentName:"h3"},"approve")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"function approve(\n        address token,\n        address spender,\n        uint192 amount,\n        uint64 duration,\n        uint64 startTime\n    )\n")),(0,o.kt)("h3",{id:"permit"},(0,o.kt)("inlineCode",{parentName:"h3"},"permit")),(0,o.kt)("p",null,'Supports EIP-20 approvals ("permits") via EIP-712 secp256k1 signatures'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"    function permit(\n        address owner,\n        address token,\n        address spender,\n        uint192 amount,\n        uint64 duration,\n        uint64 startTime,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    )\n    ```\n")),(0,o.kt)("h3",{id:"transferfrom"},(0,o.kt)("inlineCode",{parentName:"h3"},"transferFrom")),(0,o.kt)("p",null,"Transfer the underlying token from owner to recipient. Owner should have given approved the periodic allowance contract to spend tokens on his behalf for the designated token. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"    function transferFrom(\n        address token,\n        address owner,\n        address recipient,\n        uint192 amount\n    ) \n")),(0,o.kt)("h3",{id:"allowanceinfo"},(0,o.kt)("inlineCode",{parentName:"h3"},"allowanceInfo")),(0,o.kt)("p",null,"Gets the current allowance information given the owner, token and spender."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"  function allowanceInfo(\n        address owner,\n        address token,\n        address spender\n    )\n")))}u.isMDXComponent=!0}}]);